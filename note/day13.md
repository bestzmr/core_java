# 大纲

* 泛型
* 正则表达式
* 异常处理机制



# 泛型

* 认识泛型符号
* 什么是泛型
* 为什么需要泛型
* 泛型类
* 泛型方法
* 泛型类派生出来的子类
* 泛型通配符
* 设置泛型通配符界限
* 泛型擦除
* 泛型K,V



## 泛型符号

* E - 元素-对象

* T - 类型

* K,V - 键值对,K-键,V-值

* ***? - 比较特殊,泛型通配符***

  

## 什么是泛型

Java泛型设计原则：只要在编译时期没有出现警告，那么运行时期就不会出现ClassCastException异常

泛型：**把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型**

**参数化类型:**

- **把类型当作是参数一样传递** - 隐形的
- **`<数据类型>` 只能是引用类型** - 泛型只能是对象类型



## 为什么需要泛型

**早期Java是使用Object来代表任意类型的，但是向下转型有强转的问题，这样程序就不太安全**

首先，我们来试想一下：没有泛型，集合会怎么样 - ***jdk5.x为什么要引入泛型???***

- Collection、Map集合对元素的类型是没有任何限制的。**本来我的Collection集合装载的是全部的Dog对象，但是外边把Cat对象存储到集合中，是没有任何语法错误的。**

- 把对象扔进集合中，集合是不知道元素的类型是什么的，仅仅知道是Object。因此在get()的时候，返回的是Object。**外边获取该对象，还需要强制转换**

  

***有了泛型以后:***

- 代码更加简洁【不用强制转换】
- 程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】
- 可读性和稳定性【在编写集合的时候，就限定了类型】



## 泛型类

**泛型类就是把泛型定义在类上，用户使用该类的时候，才把类型明确下来**....这样的话，用户明确了什么类型，该类就代表着什么类型...用户在使用的时候就不用担心强转的问题，运行时转换异常的问题了。



## 泛型方法

我们可能就仅仅在**某一个方法上需要使用泛型**....**外界仅仅是关心该方法，不关心类其他的属性**...这样的话，我们在整个类上定义泛型，未免就有些大题小作了



## 泛型类派生出来的子类

**泛型类是拥有泛型这个特性的类，它本质上还是一个Java类，那么它就可以被继承**

那它是怎么被继承的呢？？这里分两种情况

1. **子类明确泛型类的类型参数变量**
2. **子类不明确泛型类的类型参数变量**



## 泛型通配符

**?号通配符表示可以匹配任意类型，任意的Java类都可以匹配**.....

现在非常值得注意的是，当我们使用?号通配符的时候：**就只能调对象与类型无关的方法，不能调用对象与类型有关的方法。**



## 设置泛型通配符界限

* <? super Type>

  传递进来的只能是Type或Type的父类

* <? extends Type>

  传进来的只能是Type或者Type的子类



## 泛型擦除

泛型是**提供给javac编译器使用的**，它用于限定集合的输入类型，让编译器在源代码级别上，即挡住向集合中插入非法数据。但编译器编译完带有泛形的java程序后，**生成的class文件中将不再带有泛形信息**，以此使程序运行效率不受到影响，这个过程称之为“擦除”。